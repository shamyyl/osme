/**
 * Выполняет указанное асинхронное действие над массивом.
 */
var executer = require('executer.js');

function threadAsync (limit) {
	var _executer = new executer(limit || 8);

	return function (array, action, callback, verbose) {
		if (!array.length) {
			callback();
		} else {
			var loadCounter = 0,
				arrayLength = array.length,
				percent = 0;

			array.forEach(function (item) {
				_executer.add(function (completeCallback) {
					action(item, function () {
						completeCallback();
						if (verbose) {
							var completed = Math.round(10 * loadCounter / arrayLength)
							if (completed > percent) {
								console.log(completed * 10, loadCounter);
							}
							percent = completed;
						}
						if (++loadCounter === arrayLength) {
							callback(array)
						}
					});
				});
			});
		}
	};
}


module.exports.forEach = threadAsync();

var threads = {};
module.exports.thread = function (id, limit) {
	var thread = 0;
	if (!threads[id]) {
		thread = {forEach: threadAsync(limit)}
	}
	if (id >= 0) {
		threads[id] = thread;
	}
	return thread;
}

module.exports.all = function (list, callback) {
	if (!list.length) {
		callback();
	} else {
		var counter = list.length;
		var echo = counter > 200;

		function listCallback () {
			counter--;
			if (echo && counter & 100 == 0) {
				console.log(counter, "...");
			}
			if (!counter) {
				callback();
			}
		}

		for (var i = 0; i < list.length; i++) {
			list[i](listCallback);
		}
	}
};